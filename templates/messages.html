{% extends 'base.html' %}
{% load static %}

{% block title %}Socialite - Messages{% endblock %}

{% block content %}

<!-- WebRTC CSS -->
<link rel="stylesheet" href="{% static 'css/webrtc.css' %}">

<div class="relative overflow-hidden border -m-2.5 dark:border-slate-700">

    <div class="flex bg-white dark:bg-dark2">

        <!-- sidebar -->
        <div class="md:w-[360px] relative border-r dark:border-slate-700">

            <div id="side-chat"
                class="top-0 left-0 max-md:fixed max-md:w-5/6 max-md:h-screen bg-white z-50 max-md:shadow max-md:-translate-x-full dark:bg-dark2">

                <!-- heading title -->
                <div class="p-4 border-b dark:border-slate-700">

                    <div class="flex mt-2 items-center justify-between">

                        <h2 class="text-2xl font-bold text-black ml-1 dark:text-white"> Chats </h1>

                            <!-- right action buttons -->
                            <div class="flex items-center gap-2.5">
                                <button class="group">
                                    <ion-icon name="settings-outline"
                                        class="text-2xl flex group-aria-expanded:rotate-180"></ion-icon>
                                </button>
                                <div class="md:w-[270px] w-full"
                                    uk-dropdown="pos: bottom-left; offset:10; animation: uk-animation-slide-bottom-small">
                                    <nav>
                                        <a href="#"> <ion-icon class="text-2xl shrink-0 -ml-1"
                                                name="checkmark-outline"></ion-icon> Mark all as read </a>
                                        <a href="#"> <ion-icon class="text-2xl shrink-0 -ml-1"
                                                name="notifications-outline"></ion-icon> notifications setting </a>
                                        <a href="#"> <ion-icon class="text-xl shrink-0 -ml-1"
                                                name="volume-mute-outline"></ion-icon> Mute notifications </a>
                                    </nav>
                                </div>

                                <button class="">
                                    <ion-icon name="checkmark-circle-outline" class="text-2xl flex"></ion-icon>
                                </button>

                                <!-- mobile toggle menu -->
                                <button type="button" class="md:hidden"
                                    uk-toggle="target: #side-chat ; cls: max-md:-translate-x-full">
                                    <ion-icon name="chevron-down-outline"></ion-icon>
                                </button>

                            </div>

                    </div>

                    <!-- search -->
                    <div class="relative mt-4">
                        <div class="absolute left-3 bottom-1/2 translate-y-1/2 flex"><ion-icon name="search"
                                class="text-xl"></ion-icon></div>
                        <input type="text" id="user-search" placeholder="Search users..." class="w-full !pl-10 !py-2 !rounded-lg">
                        <div id="search-results" class="absolute top-full left-0 right-0 bg-white dark:bg-dark2 border border-gray-200 dark:border-slate-700 rounded-lg mt-1 hidden z-50 max-h-60 overflow-y-auto"></div>
                    </div>

                </div>

                <!-- users list -->
                <div id="chat-list" class="space-y-2 p-2 overflow-y-auto md:h-[calc(100vh-204px)] h-[calc(100vh-130px)]">
                    <!-- Chat rooms will be loaded here dynamically -->
                </div>

            </div>

            <!-- overly -->
            <div id="side-chat"
                class="bg-slate-100/40 backdrop-blur w-full h-full dark:bg-slate-800/40 z-40 fixed inset-0 max-md:-translate-x-full md:hidden"
                uk-toggle="target: #side-chat ; cls: max-md:-translate-x-full"></div>

        </div>

        <!-- message center -->
        <div class="flex-1">

            <!-- chat heading -->
            <div id="chat-header"
                class="flex items-center justify-between gap-2 w- px-6 py-3.5 z-10 border-b dark:border-slate-700 uk-animation-slide-top-medium hidden">

                <div class="flex items-center sm:gap-4 gap-2">

                    <!-- toggle for mobile -->
                    <button type="button" class="md:hidden"
                        uk-toggle="target: #side-chat ; cls: max-md:-translate-x-full">
                        <ion-icon name="chevron-back-outline" class="text-2xl -ml-4"></ion-icon>
                    </button>

                    <div class="relative cursor-pointer max-md:hidden" uk-toggle="target: .rightt ; cls: hidden">
                        <img id="chat-avatar" src="" alt=""
                            class="w-8 h-8 rounded-full shadow">
                        <div id="online-indicator" class="w-2 h-2 bg-teal-500 rounded-full absolute right-0 bottom-0 m-px hidden"></div>
                    </div>
                    <div class="cursor-pointer" uk-toggle="target: .rightt ; cls: hidden">
                        <div id="chat-name" class="text-base font-bold"></div>
                        <div id="chat-status" class="text-xs text-green-500 font-semibold">Online</div>
                    </div>

                </div>

                <div class="flex items-center gap-2">
                    <button type="button" id="voice-call-btn" class="button__ico">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-6 h-6">
                            <path fill-rule="evenodd"
                                d="M2 3.5A1.5 1.5 0 013.5 2h1.148a1.5 1.5 0 011.465 1.175l.716 3.223a1.5 1.5 0 01-1.052 1.767l-.933.267c-.41.117-.643.555-.48.95a11.542 11.542 0 006.254 6.254c.395.163.833-.07.95-.48l.267-.933a1.5 1.5 0 011.767-1.052l3.223.716A1.5 1.5 0 0118 15.352V16.5a1.5 1.5 0 01-1.5 1.5H15c-1.149 0-2.263-.15-3.326-.43A13.022 13.022 0 012.43 8.326 13.019 13.019 0 012 5V3.5z"
                                clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button type="button" id="video-call-btn" class="hover:bg-slate-100 p-1.5 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round"
                                d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                        </svg>
                    </button>
                    <button type="button" class="hover:bg-slate-100 p-1.5 rounded-full"
                        uk-toggle="target: .rightt ; cls: hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" />
                        </svg>
                    </button>
                </div>

            </div>

            <!-- Welcome message when no chat selected -->
            <div id="welcome-message" class="flex items-center justify-center h-full">
                <div class="text-center">
                    <div class="text-6xl mb-4">üí¨</div>
                    <h3 class="text-xl font-semibold text-gray-600 dark:text-gray-300 mb-2">Welcome to Messages</h3>
                    <p class="text-gray-500 dark:text-gray-400">Select a chat to start messaging</p>
                </div>
            </div>

            <!-- chats bubble -->
            <div id="messages-container" class="w-full p-5 py-10 overflow-y-auto md:h-[calc(100vh-204px)] h-[calc(100vh-195px)] hidden">
                <div id="messages-list" class="text-sm font-medium space-y-6">
                    <!-- Messages will be loaded here dynamically -->
                </div>
            </div>

            <!-- sending message area -->
            <div id="message-input-area" class="flex items-center md:gap-4 gap-2 md:p-3 p-2 overflow-hidden hidden">

                <!-- File upload button -->
                <div class="flex items-center gap-2">
                    <button type="button" id="file-upload-btn" class="text-gray-600 hover:text-blue-600 transition-colors duration-200 p-2 rounded-full hover:bg-gray-100">
                        <ion-icon class="w-5 h-5" name="attach-outline"></ion-icon>
                    </button>
                    <input type="file" id="file-input" class="hidden" multiple accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.txt,.zip,.rar">
                </div>

                <div class="relative flex-1">
                    <textarea id="message-input" placeholder="Write your message" rows="1"
                        class="w-full resize-none bg-secondery rounded-full px-4 p-2 pr-12 focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>

                    <button type="button" id="send-button" class="text-blue-600 hover:text-blue-700 shrink-0 p-2 absolute right-1 top-1/2 transform -translate-y-1/2 transition-colors duration-200 rounded-full hover:bg-blue-50">
                        <ion-icon class="w-5 h-5" name="paper-plane-outline"></ion-icon>
                    </button>

                </div>

                <!-- File preview area -->
                <div id="file-preview-area" class="hidden flex-wrap gap-2 max-w-xs">
                    <!-- File previews will be added here dynamically -->
                </div>

            </div>

        </div>

        <!-- user profile right info -->
        <div class="rightt w-full h-full absolute top-0 right-0 z-10 hidden transition-transform">
            <div
                class="w-[360px] border-l shadow-lg h-screen bg-white absolute right-0 top-0 uk-animation-slide-right-medium delay-200 z-50 dark:bg-dark2 dark:border-slate-700">

                <div class="w-full h-1.5 bg-gradient-to-r to-purple-500 via-red-500 from-pink-500 -mt-px"></div>

                <div class="py-10 text-center text-sm pt-20">
                    <img id="profile-avatar" src="" class="w-24 h-24 rounded-full mx-auto mb-3" alt="">
                    <div class="mt-8">
                        <div id="profile-name" class="md:text-xl text-base font-medium text-black dark:text-white"></div>
                        <div id="profile-username" class="text-gray-500 text-sm mt-1 dark:text-white/80"></div>
                    </div>
                    <div class="mt-5">
                        <a href="#" id="profile-link"
                            class="inline-block rounded-full px-4 py-1.5 text-sm font-semibold bg-secondery">View
                            profile</a>
                    </div>
                </div>

                <hr class="opacity-80 dark:border-slate-700">

                <ul class="text-base font-medium p-3">
                    <li>
                        <div class="flex items-center gap-5 rounded-md p-3 w-full hover:bg-secondery">
                            <ion-icon name="notifications-off-outline" class="text-2xl"></ion-icon> Mute Notification
                            <label class="switch cursor-pointer ml-auto"> <input type="checkbox" checked><span
                                    class="switch-button !relative"></span></label>
                        </div>
                    </li>
                    <li> <button type="button" class="flex items-center gap-5 rounded-md p-3 w-full hover:bg-secondery">
                            <ion-icon name="flag-outline" class="text-2xl"></ion-icon> Report </button></li>
                    <li> <button type="button" class="flex items-center gap-5 rounded-md p-3 w-full hover:bg-secondery">
                            <ion-icon name="settings-outline" class="text-2xl"></ion-icon> Ignore messages </button>
                    </li>
                    <li> <button type="button" class="flex items-center gap-5 rounded-md p-3 w-full hover:bg-secondery">
                            <ion-icon name="stop-circle-outline" class="text-2xl"></ion-icon> Block </button> </li>
                    <li> <button type="button"
                            class="flex items-center gap-5 rounded-md p-3 w-full hover:bg-red-50 text-red-500">
                            <ion-icon name="trash-outline" class="text-2xl"></ion-icon> Delete Chat </button> </li>
                </ul>

                <!-- close button -->
                <button type="button" class="absolute top-0 right-0 m-4 p-2 bg-secondery rounded-full"
                    uk-toggle="target: .rightt ; cls: hidden">
                    <ion-icon name="close" class="text-2xl flex"></ion-icon>
                </button>

            </div>

            <!-- overly -->
            <div class="bg-slate-100/40 backdrop-blur w-full h-full dark:bg-slate-800/40 z-40 fixed inset-0"
                uk-toggle="target: .rightt ; cls: hidden"></div>

        </div>

    </div>

</div>

<!-- WebRTC Call Interface -->
<div id="call-interface" class="call-interface hidden">
    <!-- Incoming Call -->
    <div id="incoming-call" class="incoming-call hidden">
        <div class="call-avatar">
            <img id="caller-avatar" src="" alt="Caller">
        </div>
        <div class="call-info">
            <h3 id="caller-name">Incoming Call</h3>
            <p id="call-type">Voice Call</p>
        </div>
        <div class="call-actions">
            <button id="decline-call" class="call-btn decline">
                <ion-icon name="call-outline"></ion-icon>
            </button>
            <button id="accept-call" class="call-btn accept">
                <ion-icon name="call-outline"></ion-icon>
            </button>
        </div>
    </div>

    <!-- Active Call -->
    <div id="active-call" class="active-call hidden">
        <div class="video-container">
            <video id="remote-video" class="remote-video" autoplay playsinline></video>
            <video id="local-video" class="local-video" autoplay playsinline muted></video>
        </div>
        
        <div class="call-controls">
            <button id="toggle-mute" class="control-btn">
                <ion-icon name="mic-outline"></ion-icon>
            </button>
            <button id="toggle-camera" class="control-btn">
                <ion-icon name="videocam-outline"></ion-icon>
            </button>
            <button id="end-call" class="control-btn end-call">
                <ion-icon name="call-outline"></ion-icon>
            </button>
        </div>
        
        <div class="call-status">
            <span id="call-duration">00:00</span>
        </div>
    </div>
</div>

<script>
class ChatApp {
    constructor() {
        this.currentChatId = null;
        this.currentSocket = null;
        this.currentUser = null;
        this.pollingInterval = null;
        this.chatListPollingInterval = null;
        this.lastMessageId = null;
        this.webrtcManager = null;
        this.currentRecipientId = null;
        this.init();
    }

    async init() {
        await this.getCurrentUser();
        await this.loadChats();
        this.setupEventListeners();
        this.initializeWebRTC();
        this.setupCallButtons();
        
        // Start chat list polling for real-time updates
        this.startChatListPolling();
    }

    initializeWebRTC() {
        console.log('Initializing WebRTC manager...');
        this.webrtcManager = new WebRTCManager();
        console.log('WebRTC manager initialized:', this.webrtcManager);
        
        // Make WebRTC manager globally accessible for debugging
        window.webrtcManager = this.webrtcManager;
    }

    setupCallButtons() {
        console.log('Setting up call buttons...');
        const voiceCallBtn = document.getElementById('voice-call-btn');
        const videoCallBtn = document.getElementById('video-call-btn');

        console.log('Voice call button found:', voiceCallBtn);
        console.log('Video call button found:', videoCallBtn);

        if (voiceCallBtn) {
            voiceCallBtn.addEventListener('click', () => {
                console.log('Voice call button clicked!');
                if (this.currentRecipientId) {
                    console.log('Starting voice call with user:', this.currentRecipientId);
                    if (this.webrtcManager) {
                        this.webrtcManager.startCall(this.currentRecipientId, false);
                    } else {
                        console.error('WebRTC manager not initialized');
                    }
                } else {
                    console.error('No recipient selected for call');
                }
            });
            console.log('Voice call button event listener attached');
        } else {
            console.error('Voice call button not found!');
        }

        if (videoCallBtn) {
            videoCallBtn.addEventListener('click', () => {
                console.log('Video call button clicked!');
                if (this.currentRecipientId) {
                    console.log('Starting video call with user:', this.currentRecipientId);
                    if (this.webrtcManager) {
                        this.webrtcManager.startCall(this.currentRecipientId, true);
                    } else {
                        console.error('WebRTC manager not initialized');
                    }
                } else {
                    console.error('No recipient selected for call');
                }
            });
            console.log('Video call button event listener attached');
        } else {
            console.error('Video call button not found!');
        }
    }

    async getCurrentUser() {
        try {
            // First try session-based authentication
            let response = await fetch('/api/user/session/');
            
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.user) {
                    this.currentUser = data.user;
                    console.log('Current user loaded via session:', this.currentUser);
                    return;
                }
            }
            
            // Fall back to JWT token authentication
            const token = localStorage.getItem('token');
            if (!token) {
                console.error('No authentication token found and session auth failed');
                window.location.href = '/login/';
                return;
            }

            response = await fetch('/api/user/', {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.user) {
                    this.currentUser = data.user;
                    console.log('Current user loaded via JWT:', this.currentUser);
                } else {
                    console.error('Failed to get user data:', data);
                }
            } else if (response.status === 401) {
                console.error('Authentication failed - redirecting to login');
                localStorage.removeItem('token');
                window.location.href = '/login/';
            }
        } catch (error) {
            console.error('Error getting current user:', error);
        }
    }

    async loadChats() {
        try {
            // First try session-based authentication
            let response = await fetch('/api/chats/session/');
            
            if (response.ok) {
                const chats = await response.json();
                this.renderChatList(chats);
                return;
            }
            
            // Fall back to JWT token authentication
            const token = localStorage.getItem('token');
            if (!token) {
                console.error('No authentication token found and session auth failed');
                return;
            }

            response = await fetch('/api/chats/', {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            if (response.ok) {
                const chats = await response.json();
                this.renderChatList(chats);
            } else if (response.status === 401) {
                console.error('Authentication failed for chats');
                localStorage.removeItem('token');
                window.location.href = '/login/';
            }
        } catch (error) {
            console.error('Error loading chats:', error);
        }
    }

    renderChatList(chats) {
        const chatList = document.getElementById('chat-list');
        chatList.innerHTML = '';

        chats.forEach(chat => {
            const chatElement = document.createElement('a');
            chatElement.href = '#';
            chatElement.className = 'relative flex items-center gap-4 p-2 duration-200 rounded-xl hover:bg-secondery';
            chatElement.onclick = (e) => {
                e.preventDefault();
                // Use other_participant data if available, otherwise fallback to name
                const otherUser = chat.other_participant || { 
                    first_name: chat.name.split(' ')[0] || '',
                    last_name: chat.name.split(' ').slice(1).join(' ') || '',
                    username: chat.name,
                    avatar: chat.avatar_url
                };
                this.openChat(chat.id, otherUser);
            };

            chatElement.innerHTML = `
                <div class="relative w-14 h-14 shrink-0">
                    <img src="${chat.avatar_url || '/static/images/avatars/avatar-1.webp'}" alt=""
                        class="object-cover w-full h-full rounded-full">
                    <div class="w-4 h-4 absolute bottom-0 right-0 bg-green-500 rounded-full border border-white dark:border-slate-800"></div>
                </div>
                <div class="flex-1 min-w-0">
                    <div class="flex items-center gap-2 mb-1.5">
                        <div class="mr-auto text-sm text-black dark:text-white font-medium">${chat.name}</div>
                        <div class="text-xs font-light text-gray-500 dark:text-white/70">${chat.last_message_at ? new Date(chat.last_message_at).toLocaleTimeString() : ''}</div>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="overflow-hidden text-ellipsis text-sm whitespace-nowrap flex-1 ${chat.unread_count > 0 ? 'font-bold text-black dark:text-white' : 'font-medium text-gray-600 dark:text-gray-300'}">
                            ${chat.last_message || 'No messages yet'}
                        </div>
                        ${chat.unread_count > 0 ? `
                            <div class="bg-red-500 text-white text-xs font-bold rounded-full w-5 h-5 flex items-center justify-center min-w-[20px] ml-2">${chat.unread_count}</div>
                        ` : ''}
                    </div>
                </div>
            `;

            chatList.appendChild(chatElement);
        });
    }

    async openChat(chatId, otherUser) {
        // Close existing socket connection and stop polling
        if (this.currentSocket) {
            this.currentSocket.close();
        }
        this.stopPolling();

        this.currentChatId = chatId;
        this.currentRecipientId = otherUser.id;
        
        // Show chat interface
        document.getElementById('welcome-message').classList.add('hidden');
        document.getElementById('chat-header').classList.remove('hidden');
        document.getElementById('messages-container').classList.remove('hidden');
        document.getElementById('message-input-area').classList.remove('hidden');

        // Update chat header
        document.getElementById('chat-avatar').src = otherUser.avatar || '/static/images/avatars/avatar-1.webp';
        document.getElementById('chat-name').textContent = `${otherUser.first_name} ${otherUser.last_name}`;
        
        // Update profile sidebar
        document.getElementById('profile-avatar').src = otherUser.avatar || '/static/images/avatars/avatar-1.webp';
        document.getElementById('profile-name').textContent = `${otherUser.first_name} ${otherUser.last_name}`;
        document.getElementById('profile-username').textContent = `@${otherUser.username}`;

        // Load messages
        await this.loadMessages(chatId);

        // Refresh chat list to update unread count after marking messages as read
        this.loadChats();

        // Start polling for new messages
        this.startPolling();

        // Connect to WebSocket (fallback)
        this.connectWebSocket(chatId);
    }

    async loadMessages(chatId) {
        try {
            const response = await fetch(`/api/chats/${chatId}/messages/`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.messages) {
                    this.renderMessages(data.messages);
                } else {
                    console.error('Error loading messages:', data.error || 'Unknown error');
                }
            } else {
                console.error('Error loading messages: HTTP', response.status);
            }
        } catch (error) {
            console.error('Error loading messages:', error);
        }
    }

    renderMessages(messages) {
        const messagesList = document.getElementById('messages-list');
        messagesList.innerHTML = '';

        messages.forEach(message => {
            const messageElement = this.createMessageElement(message);
            messagesList.appendChild(messageElement);
        });

        // Track the last message ID for polling
        if (messages.length > 0) {
            this.lastMessageId = messages[messages.length - 1].id;
        }

        // Scroll to bottom
        const container = document.getElementById('messages-container');
        container.scrollTop = container.scrollHeight;
    }

    createMessageElement(message) {
    const messageDiv = document.createElement('div');
    messageDiv.setAttribute('data-message-id', message.id);
    
    const isOwn = this.currentUser && (message.sender.id === this.currentUser.id || message.sender.username === this.currentUser.username);
    
    const getAvatarUrl = (message) => {
        return message.sender?.avatar_url || 
               message.sender?.avatar || 
               message.avatar || 
               '/static/images/avatars/avatar-1.webp';
    };

    const avatarUrl = getAvatarUrl(message);

    // Create message content
    let messageContent = '';
    
    if ((message.message_type === 'file' || message.message_type === 'image') && message.files && message.files.length > 0) {
        messageContent = this.createFileMessageContent(message);
    } else if (message.message_type === 'image' && message.image_url) {
        messageContent = `
            <div class="mb-2">
                <img src="${message.image_url}" alt="Image" 
                     class="max-w-full h-auto rounded-lg cursor-pointer"
                     onclick="window.open('${message.image_url}', '_blank')">
            </div>
        `;
    } else if (message.message_type === 'file' && message.file_url) {
        messageContent = `
            <div class="flex items-center gap-2 mb-2 p-2 bg-black bg-opacity-20 rounded-lg">
                <ion-icon name="document-outline" class="w-6 h-6"></ion-icon>
                <div class="flex-1 min-w-0">
                    <div class="text-sm font-medium">file</div>
                </div>
                <a href="${message.file_url}" download 
                   class="p-1">
                    <ion-icon name="download-outline" class="w-4 h-4"></ion-icon>
                </a>
            </div>
        `;
    } else {
        messageContent = message.content || '';
    }

    // ‚ú® Get sentiment data with fallback
    const sentiment = message.sentiment || {
        label: 'NEUTRAL',
        emoji: 'üòê',
        score: 0
    };

    // Show sentiment badge only for text messages with non-neutral sentiment
    const showSentiment = message.message_type === 'text' && sentiment.label !== 'NEUTRAL';

    if (isOwn) {
        // Own messages: right side
        messageDiv.className = 'flex gap-2 flex-row-reverse items-end mb-3';
        messageDiv.innerHTML = `
            <img src="${avatarUrl}" alt=""
                class="w-6 h-6 rounded-full shadow">
            <div class="px-4 py-2 rounded-[20px] max-w-sm bg-gradient-to-tr from-sky-500 to-blue-500 text-white shadow-md">
                ${messageContent}
                <div class="flex items-center justify-between mt-1 gap-2">
                    <div class="flex items-center gap-2">
                        <div class="text-xs opacity-75">${new Date(message.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                        ${showSentiment ? `
                            <span class="text-base" title="${sentiment.label} (${Math.round(sentiment.score * 100)}%)">${sentiment.emoji}</span>
                        ` : ''}
                    </div>
                    <button onclick="deleteMessage(${message.id})" class="ml-2 text-xs opacity-75 hover:opacity-100 hover:text-red-300 transition-all duration-200" title="Delete message">
                        <ion-icon name="trash-outline" class="w-4 h-4"></ion-icon>
                    </button>
                </div>
            </div>
        `;
    } else {
        // Other messages: left side
        messageDiv.className = 'flex gap-3 items-end mb-3';
        const isFileMessage = (message.message_type === 'file' || message.message_type === 'image') && 
                             ((message.files && message.files.length > 0) || message.file_url || message.image_url);
        const bgClass = isFileMessage ? 'bg-gradient-to-tr from-gray-600 to-gray-700 text-white' : 'bg-gray-200 text-gray-800';
        
        messageDiv.innerHTML = `
            <img src="${avatarUrl}" alt=""
                class="w-8 h-8 rounded-full shadow">
            <div class="px-4 py-2 rounded-[20px] max-w-sm ${bgClass} shadow-md">
                ${messageContent}
                <div class="flex items-center gap-2 mt-1">
                    <div class="text-xs opacity-75">${new Date(message.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                    ${showSentiment ? `
                        <span class="text-base" title="${sentiment.label} (${Math.round(sentiment.score * 100)}%)">${sentiment.emoji}</span>
                    ` : ''}
                </div>
            </div>
        `;
    }

    return messageDiv;
}

    createFileMessageContent(message) {
        let content = '';
        
        // Add text content if present
        if (message.content && message.content.trim()) {
            content += `<div class="mb-2">${message.content}</div>`;
        }
        
        // Add files
        message.files.forEach(file => {
            if (file.file_type && file.file_type.startsWith('image/')) {
                // Display images
                content += `
                    <div class="mb-2">
                        <img src="${file.url}" alt="${file.original_name}" 
                             class="max-w-full h-auto rounded-lg cursor-pointer"
                             onclick="window.open('${file.url}', '_blank')">
                        <div class="text-xs opacity-75 mt-1">${file.original_name} (${this.formatFileSize(file.file_size || 0)})</div>
                    </div>
                `;
            } else {
                // Display other files as downloadable links with filename, size and icon
                const fileIcon = this.getFileIconForDisplay(file.file_type);
                content += `
                    <div class="flex items-center gap-2 mb-2 p-2 bg-black bg-opacity-20 rounded-lg">
                        <ion-icon name="${fileIcon}" class="w-6 h-6"></ion-icon>
                        <div class="flex-1 min-w-0">
                            <div class="text-sm font-medium">${file.original_name}</div>
                            <div class="text-xs opacity-75">${this.formatFileSize(file.file_size || 0)}</div>
                        </div>
                        <a href="${file.url}" download="${file.original_name}" 
                           class="p-1">
                            <ion-icon name="download-outline" class="w-4 h-4"></ion-icon>
                        </a>
                    </div>
                `;
            }
        });
        
        return content;
    }

    getFileIconForDisplay(fileType) {
        if (!fileType) return 'document-outline';
        if (fileType.startsWith('image/')) return 'image-outline';
        if (fileType.startsWith('video/')) return 'videocam-outline';
        if (fileType.startsWith('audio/')) return 'musical-notes-outline';
        if (fileType === 'application/pdf') return 'document-text-outline';
        if (fileType.includes('word')) return 'document-outline';
        if (fileType.includes('zip') || fileType.includes('rar')) return 'archive-outline';
        return 'document-outline';
    }

    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    startPolling() {
        // Poll for new messages every 2 seconds
        this.pollingInterval = setInterval(() => {
            if (this.currentChatId) {
                this.checkForNewMessages();
            }
        }, 2000);
    }

    stopPolling() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
            this.pollingInterval = null;
        }
    }

    async checkForNewMessages() {
        try {
            const response = await fetch(`/api/chats/${this.currentChatId}/messages/`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.messages) {
                    // Check if there are new messages
                    const newMessages = this.lastMessageId ? 
                        data.messages.filter(msg => msg.id > this.lastMessageId) : 
                        data.messages;
                    
                    if (newMessages.length > 0) {
                        // Add only new messages to avoid duplicates
                        const messagesList = document.getElementById('messages-list');
                        newMessages.forEach(message => {
                            const messageElement = this.createMessageElement(message);
                            messagesList.appendChild(messageElement);
                        });
                        
                        // Update last message ID
                        this.lastMessageId = data.messages[data.messages.length - 1].id;
                        
                        // Scroll to bottom
                        const container = document.getElementById('messages-container');
                        container.scrollTop = container.scrollHeight;
                        
                        // Refresh chat list to update last message
                        this.loadChats();
                    }
                }
            }
        } catch (error) {
            console.error('Error checking for new messages:', error);
        }
    }

    // Chat list polling methods
    startChatListPolling() {
        // Stop any existing polling
        this.stopChatListPolling();
        
        // Start polling every 5 seconds for chat list updates
        this.chatListPollingInterval = setInterval(() => {
            this.loadChats();
        }, 5000);
        
        console.log('Chat list polling started');
    }

    stopChatListPolling() {
        if (this.chatListPollingInterval) {
            clearInterval(this.chatListPollingInterval);
            this.chatListPollingInterval = null;
            console.log('Chat list polling stopped');
        }
    }

    connectWebSocket(chatId) {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const token = localStorage.getItem('token');
        const wsUrl = `${protocol}//${window.location.host}/ws/chat/${chatId}/?token=${token}`;
        
        this.currentSocket = new WebSocket(wsUrl);

        this.currentSocket.onopen = () => {
            console.log('WebSocket connected');
            // Pass the WebSocket connection to WebRTC manager
            if (this.webrtcManager) {
                this.webrtcManager.setSocket(this.currentSocket);
            }
        };

        this.currentSocket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            
            if (data.type === 'message' || data.type === 'file_message') {
                const messageElement = this.createMessageElement({
                    id: data.message_id,
                    content: data.message,
                    sender: {
                        id: data.user_id,
                        username: data.user,
                        avatar: data.avatar
                    },
                    created_at: data.timestamp
                });
                document.getElementById('messages-list').appendChild(messageElement);
                
                // Scroll to bottom
                const container = document.getElementById('messages-container');
                container.scrollTop = container.scrollHeight;
                
                // Refresh chat list to update last message
                this.loadChats();
            }
            else if (data.type === 'message_deleted') {
                // Handle message deletion - find message by data attribute
                const messageElement = document.querySelector(`#messages-list > div[data-message-id="${data.message_id}"]`);
                if (messageElement) {
                    messageElement.remove();
                    console.log('Message deleted via WebSocket:', data.message_id);
                } else {
                    console.log('Message element not found for deletion:', data.message_id);
                }
            }
            // Handle WebRTC call signaling
            else if (data.type === 'call_offer') {
                this.webrtcManager.handleCallOffer(data);
            }
            else if (data.type === 'call_answer') {
                this.webrtcManager.handleCallAnswer(data);
            }
            else if (data.type === 'ice_candidate') {
                this.webrtcManager.handleIceCandidate(data);
            }
            else if (data.type === 'call_end') {
                this.webrtcManager.handleCallEnd(data);
            }
            else if (data.type === 'call_declined') {
                this.webrtcManager.handleCallDeclined(data);
            }
        };

        this.currentSocket.onclose = () => {
            console.log('WebSocket disconnected');
        };

        this.currentSocket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
    }

    async sendMessage() {
        const messageInput = document.getElementById('message-input');
        const content = messageInput.value.trim();
        const selectedFiles = window.fileHandler?.getSelectedFiles() || [];
        
        if (!content && selectedFiles.length === 0) return;
        if (!this.currentChatId) return;

        // Clear input immediately for better UX
        messageInput.value = '';

        try {
            // If there are files, send them first
            if (selectedFiles.length > 0) {
                await this.sendFilesMessage(selectedFiles, content);
                window.fileHandler?.clearFiles();
            } else {
                // Send text message only
                await this.sendTextMessage(content);
            }
        } catch (error) {
            console.error('Error sending message:', error);
            // Restore message input if sending failed
            messageInput.value = content;
        }
    }

    async sendTextMessage(content) {
        const response = await fetch(`/api/chats/${this.currentChatId}/send/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
            },
            body: JSON.stringify({
                content: content,
                message_type: 'text'
            })
        });

        if (response.ok) {
            const result = await response.json();
            
            // Immediately add the message to UI for instant feedback
            if (result.success && result.message) {
                const messageElement = this.createMessageElement(result.message);
                const messagesList = document.getElementById('messages-list');
                messagesList.appendChild(messageElement);
                
                // Update last message ID
                this.lastMessageId = result.message.id;
                
                // Scroll to bottom
                const container = document.getElementById('messages-container');
                container.scrollTop = container.scrollHeight;
            }
            
            // Also send via WebSocket for real-time updates to other users
            if (this.currentSocket && this.currentSocket.readyState === WebSocket.OPEN) {
                this.currentSocket.send(JSON.stringify({
                    type: 'message',
                    message: content
                }));
            }
            
            // Refresh chat list to update last message
            this.loadChats();
        } else {
            console.error('Error sending message: HTTP', response.status);
            throw new Error('Failed to send message');
        }
    }

    async sendFilesMessage(files, content = '') {
        const formData = new FormData();
        
        // Add files to form data
        files.forEach((file, index) => {
            formData.append(`files`, file);
        });
        
        // Add text content if provided
        if (content) {
            formData.append('content', content);
        }
        
        formData.append('message_type', 'file');

        const response = await fetch(`/api/chats/${this.currentChatId}/send/`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
            },
            body: formData
        });

        if (response.ok) {
            const result = await response.json();
            
            // Immediately add the message to UI for instant feedback
            if (result.success && result.message) {
                const messageElement = this.createMessageElement(result.message);
                const messagesList = document.getElementById('messages-list');
                messagesList.appendChild(messageElement);
                
                // Update last message ID
                this.lastMessageId = result.message.id;
                
                // Scroll to bottom
                const container = document.getElementById('messages-container');
                container.scrollTop = container.scrollHeight;
            }
            
            // Also send via WebSocket for real-time updates to other users
            if (this.currentSocket && this.currentSocket.readyState === WebSocket.OPEN) {
                this.currentSocket.send(JSON.stringify({
                    type: 'file_message',
                    message: content || 'Sent files',
                    files: files.map(f => f.name)
                }));
            }
            
            // Refresh chat list to update last message
            this.loadChats();
        } else {
            console.error('Error sending files: HTTP', response.status);
            throw new Error('Failed to send files');
        }
    }

    async searchUsers(query) {
        if (!query.trim()) {
            document.getElementById('search-results').classList.add('hidden');
            return;
        }

        try {
            const token = localStorage.getItem('token');
            if (!token) {
                console.error('No authentication token found');
                return;
            }

            const response = await fetch(`/api/users/search/?q=${encodeURIComponent(query)}`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            if (response.ok) {
                const users = await response.json();
                this.renderSearchResults(users);
            } else if (response.status === 401) {
                console.error('Authentication failed for user search');
                localStorage.removeItem('token');
                window.location.href = '/login/';
            }
        } catch (error) {
            console.error('Error searching users:', error);
        }
    }

    renderSearchResults(users) {
        const searchResults = document.getElementById('search-results');
        searchResults.innerHTML = '';

        if (users.length === 0) {
            searchResults.innerHTML = '<div class="p-3 text-gray-500">No users found</div>';
        } else {
            users.forEach(user => {
                const userElement = document.createElement('div');
                userElement.className = 'flex items-center gap-3 p-3 hover:bg-gray-100 dark:hover:bg-slate-700 cursor-pointer';
                userElement.onclick = () => this.createPrivateChat(user);
                
                userElement.innerHTML = `
                    <img src="${user.avatar || '/static/images/avatars/avatar-1.webp'}" alt=""
                        class="w-10 h-10 rounded-full">
                    <div>
                        <div class="font-medium text-black dark:text-white">${user.first_name} ${user.last_name}</div>
                        <div class="text-sm text-gray-500 dark:text-gray-400">@${user.username}</div>
                    </div>
                `;
                
                searchResults.appendChild(userElement);
            });
        }

        searchResults.classList.remove('hidden');
    }

    async createPrivateChat(user) {
        try {
            const response = await fetch('/api/chats/create/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('token')}`,
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
                },
                body: JSON.stringify({
                    user_id: user.id
                })
            });

            if (response.ok) {
                const chat = await response.json();
                document.getElementById('search-results').classList.add('hidden');
                document.getElementById('user-search').value = '';
                this.loadChats(); // Refresh chat list
                this.openChat(chat.chat_id, user);
            } else {
                const errorData = await response.json();
                console.error('Error creating chat:', errorData);
                alert('Error creating chat: ' + (errorData.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Error creating private chat:', error);
        }
    }

    setupEventListeners() {
        // Send message on button click
        const sendButton = document.getElementById('send-button');
        if (sendButton) {
            sendButton.addEventListener('click', () => {
                this.sendMessage();
            });
        }

        // Send message on alternative send button click (if exists)
        const sendButtonAlt = document.getElementById('send-button-alt');
        if (sendButtonAlt) {
            sendButtonAlt.addEventListener('click', () => {
                this.sendMessage();
            });
        }

        // Send message on Enter key
        const messageInput = document.getElementById('message-input');
        if (messageInput) {
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
        }

        // User search
        let searchTimeout;
        const userSearch = document.getElementById('user-search');
        if (userSearch) {
            userSearch.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    this.searchUsers(e.target.value);
                }, 300);
            });
        }

        // Hide search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#user-search') && !e.target.closest('#search-results')) {
                const searchResults = document.getElementById('search-results');
                if (searchResults) {
                    searchResults.classList.add('hidden');
                }
            }
        });

        // Emoji button functionality
        const emojiButton = document.getElementById('emoji-button');
        if (emojiButton) {
            emojiButton.addEventListener('click', () => {
                this.toggleEmojiPicker();
            });
        }
    }

    toggleEmojiPicker() {
        const existingPopup = document.getElementById('emoji-popup');
        if (existingPopup) {
            existingPopup.remove();
            return;
        }

        const emojis = ['üòä', 'üòÇ', '‚ù§Ô∏è', 'üëç', 'üéâ', 'üòç', 'üî•', 'üíØ', '‚ú®', 'üôå', 'üëè', 'ü§î', 'üòé', 'ü•≥', 'üò¢', 'üò†', 'ü§ó', 'üòò', 'ü•∞', 'üòã'];
        
        const emojiHtml = emojis.map(emoji => 
            `<button type="button" onclick="chatApp.addEmojiToMessage('${emoji}')" class="text-2xl hover:scale-125 transition p-1 rounded hover:bg-gray-100">${emoji}</button>`
        ).join('');
        
        const popup = document.createElement('div');
        popup.id = 'emoji-popup';
        popup.className = 'absolute bottom-full left-0 mb-2 bg-white rounded-lg shadow-2xl border-2 border-gray-200 p-3 grid grid-cols-5 gap-2 z-30 dark:bg-gray-800 dark:border-gray-600';
        popup.innerHTML = emojiHtml;
        
        const emojiButton = document.getElementById('emoji-button');
        emojiButton.parentElement.style.position = 'relative';
        emojiButton.parentElement.appendChild(popup);

        // Close popup when clicking outside
        setTimeout(() => {
            document.addEventListener('click', this.closeEmojiPopup.bind(this), { once: true });
        }, 100);
    }

    addEmojiToMessage(emoji) {
        const messageInput = document.getElementById('message-input');
        const cursorPos = messageInput.selectionStart;
        const textBefore = messageInput.value.substring(0, cursorPos);
        const textAfter = messageInput.value.substring(cursorPos);
        
        messageInput.value = textBefore + emoji + textAfter;
        messageInput.focus();
        
        // Set cursor position after the emoji
        messageInput.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
        
        // Close emoji popup
        document.getElementById('emoji-popup')?.remove();
    }

    closeEmojiPopup(e) {
        const popup = document.getElementById('emoji-popup');
        const emojiButton = document.getElementById('emoji-button');
        
        if (popup && !popup.contains(e.target) && !emojiButton.contains(e.target)) {
            popup.remove();
        }
    }
}

// File handling functionality
class FileHandler {
    constructor() {
        this.selectedFiles = [];
        this.setupFileHandling();
    }

    setupFileHandling() {
        const fileUploadBtn = document.getElementById('file-upload-btn');
        const fileInput = document.getElementById('file-input');
        const filePreviewArea = document.getElementById('file-preview-area');

        // Click file upload button to trigger file input
        fileUploadBtn?.addEventListener('click', () => {
            fileInput.click();
        });

        // Handle file selection
        fileInput?.addEventListener('change', (e) => {
            this.handleFileSelection(e.target.files);
        });

        // Handle drag and drop
        const messageInputArea = document.getElementById('message-input-area');
        messageInputArea?.addEventListener('dragover', (e) => {
            e.preventDefault();
            messageInputArea.classList.add('bg-blue-50');
        });

        messageInputArea?.addEventListener('dragleave', (e) => {
            e.preventDefault();
            messageInputArea.classList.remove('bg-blue-50');
        });

        messageInputArea?.addEventListener('drop', (e) => {
            e.preventDefault();
            messageInputArea.classList.remove('bg-blue-50');
            this.handleFileSelection(e.dataTransfer.files);
        });
    }

    handleFileSelection(files) {
        const fileArray = Array.from(files);
        
        fileArray.forEach(file => {
            if (this.validateFile(file)) {
                this.selectedFiles.push(file);
                this.createFilePreview(file);
            }
        });

        this.updatePreviewArea();
    }

    validateFile(file) {
        const maxSize = 10 * 1024 * 1024; // 10MB
        const allowedTypes = [
            'image/jpeg', 'image/png', 'image/gif', 'image/webp',
            'video/mp4', 'video/webm', 'video/ogg',
            'audio/mp3', 'audio/wav', 'audio/ogg',
            'application/pdf', 'text/plain',
            'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'application/zip', 'application/x-rar-compressed'
        ];

        if (file.size > maxSize) {
            alert(`File "${file.name}" is too large. Maximum size is 10MB.`);
            return false;
        }

        if (!allowedTypes.includes(file.type)) {
            alert(`File type "${file.type}" is not supported.`);
            return false;
        }

        return true;
    }

    createFilePreview(file) {
        const previewDiv = document.createElement('div');
        previewDiv.className = 'relative bg-gray-100 rounded-lg p-2 flex items-center gap-2 max-w-xs';
        previewDiv.dataset.fileName = file.name;

        if (file.type.startsWith('image/')) {
            const img = document.createElement('img');
            img.className = 'w-12 h-12 object-cover rounded';
            img.src = URL.createObjectURL(file);
            previewDiv.appendChild(img);
        } else {
            const icon = document.createElement('ion-icon');
            icon.className = 'w-8 h-8 text-gray-600';
            icon.name = this.getFileIcon(file.type);
            previewDiv.appendChild(icon);
        }

        const fileInfo = document.createElement('div');
        fileInfo.className = 'flex-1 min-w-0';
        fileInfo.innerHTML = `
            <div class="text-sm font-medium text-gray-900 truncate">${file.name}</div>
            <div class="text-xs text-gray-500">${this.formatFileSize(file.size)}</div>
        `;
        previewDiv.appendChild(fileInfo);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'text-red-500 hover:text-red-700 p-1';
        removeBtn.innerHTML = '<ion-icon name="close-outline" class="w-4 h-4"></ion-icon>';
        removeBtn.addEventListener('click', () => {
            this.removeFile(file.name);
        });
        previewDiv.appendChild(removeBtn);

        return previewDiv;
    }

    getFileIcon(fileType) {
        if (fileType.startsWith('image/')) return 'image-outline';
        if (fileType.startsWith('video/')) return 'videocam-outline';
        if (fileType.startsWith('audio/')) return 'musical-notes-outline';
        if (fileType === 'application/pdf') return 'document-text-outline';
        if (fileType.includes('word')) return 'document-outline';
        if (fileType.includes('zip') || fileType.includes('rar')) return 'archive-outline';
        return 'document-outline';
    }

    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    removeFile(fileName) {
        this.selectedFiles = this.selectedFiles.filter(file => file.name !== fileName);
        this.updatePreviewArea();
    }

    updatePreviewArea() {
        const previewArea = document.getElementById('file-preview-area');
        previewArea.innerHTML = '';

        if (this.selectedFiles.length > 0) {
            previewArea.classList.remove('hidden');
            this.selectedFiles.forEach(file => {
                const preview = this.createFilePreview(file);
                previewArea.appendChild(preview);
            });
        } else {
            previewArea.classList.add('hidden');
        }
    }

    getSelectedFiles() {
        return this.selectedFiles;
    }

    clearFiles() {
        this.selectedFiles = [];
        this.updatePreviewArea();
    }
}

// Delete message function
async function deleteMessage(messageId) {
    if (!confirm('√ätes-vous s√ªr de vouloir supprimer ce message ?')) {
        return;
    }

    try {
        const chatId = window.chatApp.currentChatId;
        const response = await fetch(`/api/chats/${chatId}/messages/${messageId}/delete/`, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
                'X-CSRFToken': getCookie('csrftoken') || document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
            }
        });

        if (response.ok) {
            // Remove message from DOM using data attribute
            const messageElement = document.querySelector(`#messages-list > div[data-message-id="${messageId}"]`);
            if (messageElement) {
                messageElement.remove();
            }

            // Send WebSocket notification to other users
            if (window.chatApp.currentSocket && window.chatApp.currentSocket.readyState === WebSocket.OPEN) {
                window.chatApp.currentSocket.send(JSON.stringify({
                    type: 'message_deleted',
                    message_id: messageId,
                    chat_id: chatId
                }));
            }

            console.log('Message supprim√© avec succ√®s');
        } else {
            const errorData = await response.json();
            alert('Erreur lors de la suppression: ' + (errorData.error || 'Erreur inconnue'));
        }
    } catch (error) {
        console.error('Erreur lors de la suppression du message:', error);
        alert('Erreur lors de la suppression du message');
    }
}

// Helper function to get CSRF cookie
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Initialize chat app when page loads
document.addEventListener('DOMContentLoaded', () => {
    window.chatApp = new ChatApp();
    window.fileHandler = new FileHandler();
});
</script>

<!-- WebRTC JavaScript -->
<script src="{% static 'js/webrtc.js' %}"></script>

{% endblock %}